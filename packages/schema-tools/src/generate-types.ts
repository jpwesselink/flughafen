#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import { compileFromFile } from "json-schema-to-typescript";
import { extractEnums, generateEnumTypes } from "./enum-extractor";

interface SchemaFile {
	filename: string;
	path: string;
	outputName: string;
}

async function generateTypes(schemaDir: string, outputDir: string): Promise<void> {
	try {
		console.log("üöÄ Generating TypeScript types from JSON schemas...\n");

		// Ensure the output directory exists
		if (!fs.existsSync(outputDir)) {
			fs.mkdirSync(outputDir, { recursive: true });
		}

		// Check if schema directory exists
		if (!fs.existsSync(schemaDir)) {
			console.error("‚ùå Schema directory not found:", schemaDir);
			console.log("üí° Run `pnpm fetch-schemas` first to download schemas");
			process.exit(1);
		}

		// Find all .schema.json files
		const schemaFiles: SchemaFile[] = fs
			.readdirSync(schemaDir)
			.filter((file) => file.endsWith(".schema.json"))
			.map((file) => ({
				filename: file,
				path: path.join(schemaDir, file),
				outputName: file.replace(".schema.json", ".d.ts"),
			}));

		if (schemaFiles.length === 0) {
			console.log("‚ö†Ô∏è  No schema files found in:", schemaDir);
			return;
		}

		console.log(`üìã Found ${schemaFiles.length} schema file(s):`);
		schemaFiles.forEach((file) => console.log(`   - ${file.filename}`));
		console.log("");

		// Process each schema file
		for (const schemaFile of schemaFiles) {
			console.log(`üìù Processing ${schemaFile.filename}...`);

			const outputPath = path.join(outputDir, schemaFile.outputName);

			// Generate schema name for banner comment
			const schemaName = schemaFile.filename
				.replace(".schema.json", "")
				.replace("-", " ")
				.split(" ")
				.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
				.join(" ");

			// Read and modify the schema to have a cleaner title
			const schemaContent = fs.readFileSync(schemaFile.path, "utf8");
			const schema = JSON.parse(schemaContent);

			// Override the title to get cleaner type names
			if (schemaFile.filename.includes("workflow")) {
				schema.title = "GitHubWorkflow";
			} else if (schemaFile.filename.includes("action")) {
				schema.title = "GitHubAction";
			}

			// Create a temporary schema file with the modified title
			const tempSchemaPath = path.join(schemaDir, `temp-${schemaFile.filename}`);
			fs.writeFileSync(tempSchemaPath, JSON.stringify(schema, null, 2));

			try {
				// Generate TypeScript types from the modified schema
				const ts = await compileFromFile(tempSchemaPath, {
					bannerComment: `/**
 * Generated TypeScript definitions for ${schemaName} Schema
 *
 * This file is auto-generated from the ${schemaFile.filename} schema file.
 * Do not edit this file directly. Instead, modify the schema file
 * and regenerate the types using: pnpm generate-types
 */`,
					style: {
						bracketSpacing: true,
						printWidth: 120,
						semi: true,
						singleQuote: true,
						tabWidth: 2,
						trailingComma: "es5",
						useTabs: false,
					},
					additionalProperties: false,
					enableConstEnums: true,
					format: true,
					ignoreMinAndMaxItems: false,
					maxItems: 20,
					strictIndexSignatures: false,
					unknownAny: true,
					unreachableDefinitions: false,
				});

				// Write the generated types to file
				fs.writeFileSync(outputPath, ts);
				console.log(`‚úÖ Types generated for ${schemaFile.filename} ‚Üí ${schemaFile.outputName}`);
				console.log(`üì¶ File size: ${(fs.statSync(outputPath).size / 1024).toFixed(2)} KB`);
			} finally {
				// Clean up the temporary schema file
				fs.unlinkSync(tempSchemaPath);
			}
		}

		console.log(`\nüéâ Successfully generated types for ${schemaFiles.length} schema file(s)!`);
		console.log(`üìÅ Output directory: ${outputDir}`);

		// Generate schema defaults file
		console.log("\nüìù Generating schema defaults...");
		await generateSchemaDefaults(schemaDir, outputDir);
	} catch (error) {
		console.error("‚ùå Error generating types:", error);
		process.exit(1);
	}
}

/**
 * Generate a TypeScript file with schema-based default values and all enum types
 */
async function generateSchemaDefaults(schemaDir: string, outputDir: string): Promise<void> {
	const actionSchemaPath = path.join(schemaDir, "github-action.schema.json");
	const workflowSchemaPath = path.join(schemaDir, "github-workflow.schema.json");

	if (!fs.existsSync(actionSchemaPath) || !fs.existsSync(workflowSchemaPath)) {
		console.log("‚ö†Ô∏è  Required schemas not found, skipping defaults generation");
		return;
	}

	const actionSchema = JSON.parse(fs.readFileSync(actionSchemaPath, "utf8"));
	const workflowSchema = JSON.parse(fs.readFileSync(workflowSchemaPath, "utf8"));

	// Extract all enums from both schemas
	const actionEnums = extractEnums(actionSchema, "action");
	const workflowEnums = extractEnums(workflowSchema, "workflow");
	const allEnums = [...actionEnums, ...workflowEnums];

	console.log(
		`üìä Found ${allEnums.length} enum definitions (${actionEnums.length} from action schema, ${workflowEnums.length} from workflow schema)`
	);

	// Find the RunsJavascriptUsing enum to extract latest version
	const nodeRuntimeEnum = allEnums.find((e) => e.typeName === "RunsJavascriptUsing");
	if (!nodeRuntimeEnum) {
		console.log("‚ö†Ô∏è  No Node.js runtime versions found in schema");
		return;
	}

	const nodeVersions = (nodeRuntimeEnum.values as string[])
		.filter((v) => v.startsWith("node"))
		.map((v) => parseInt(v.replace("node", ""), 10))
		.sort((a, b) => b - a);

	const latestNodeVersion = nodeVersions[0];
	const supportedNodeVersions = nodeVersions.filter((v) => v !== 12).map((v) => `node${v}`);

	// Generate the defaults TypeScript file with ALL enums
	const defaultsContent = `/**
 * Schema-based defaults and enums for GitHub Actions and Workflows
 *
 * This file is AUTO-GENERATED from:
 * - github-action.schema.json
 * - github-workflow.schema.json
 *
 * Do not edit this file directly. Instead, run: pnpm generate-types
 *
 * Generated on: ${new Date().toISOString()}
 * Total enums: ${allEnums.length}
 */

${generateEnumTypes(allEnums)}

// ============================================================================
// Special Constants
// ============================================================================

/**
 * The latest Node.js runtime version supported by GitHub Actions
 *
 * This constant is extracted from the GitHub Action schema at build time.
 * When GitHub adds support for newer Node versions, this will automatically
 * update after running: pnpm fetch-schemas && pnpm generate-types
 *
 * Current value: node${latestNodeVersion}
 */
export const DEFAULT_NODE_RUNTIME = "node${latestNodeVersion}" as const;

/**
 * Supported Node.js runtime versions (excluding deprecated versions)
 * Currently excludes: node12 (deprecated)
 */
export type SupportedNodeRuntime = ${supportedNodeVersions.map((v: string) => `"${v}"`).join(" | ")};

/**
 * Supported Node.js runtime versions in descending order (newest first, excluding deprecated)
 */
export const SUPPORTED_NODE_RUNTIMES: readonly SupportedNodeRuntime[] = [${supportedNodeVersions.map((v: string) => `"${v}"`).join(", ")}] as const;
`;

	const defaultsPath = path.join(outputDir, "schema-defaults.ts");
	fs.writeFileSync(defaultsPath, defaultsContent);

	console.log(`‚úÖ Schema defaults generated ‚Üí schema-defaults.ts`);
	console.log(`   Total enums extracted: ${allEnums.length}`);
	console.log(`   Default Node runtime: node${latestNodeVersion}`);
	console.log(`   File size: ${(fs.statSync(defaultsPath).size / 1024).toFixed(2)} KB`);
}

export { generateTypes, generateSchemaDefaults };
