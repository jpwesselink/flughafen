#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { compileFromFile } from "json-schema-to-typescript";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface SchemaFile {
	filename: string;
	path: string;
	outputName: string;
}

async function generateTypes(): Promise<void> {
	try {
		console.log("üöÄ Generating TypeScript types from JSON schemas...\n");

		const schemaDir = path.join(__dirname, "..", "schemas");
		const outputDir = path.join(__dirname, "..", "generated", "types");

		// Ensure the output directory exists
		if (!fs.existsSync(outputDir)) {
			fs.mkdirSync(outputDir, { recursive: true });
		}

		// Check if schema directory exists
		if (!fs.existsSync(schemaDir)) {
			console.error("‚ùå Schema directory not found:", schemaDir);
			console.log("üí° Run `npm run fetch-schemas` first to download schemas");
			process.exit(1);
		}

		// Find all .schema.json files
		const schemaFiles: SchemaFile[] = fs
			.readdirSync(schemaDir)
			.filter((file) => file.endsWith(".schema.json"))
			.map((file) => ({
				filename: file,
				path: path.join(schemaDir, file),
				outputName: file.replace(".schema.json", ".d.ts"),
			}));

		if (schemaFiles.length === 0) {
			console.log("‚ö†Ô∏è  No schema files found in:", schemaDir);
			return;
		}

		console.log(`üìã Found ${schemaFiles.length} schema file(s):`);
		schemaFiles.forEach((file) => console.log(`   - ${file.filename}`));
		console.log("");

		// Process each schema file
		for (const schemaFile of schemaFiles) {
			console.log(`üìù Processing ${schemaFile.filename}...`);

			const outputPath = path.join(outputDir, schemaFile.outputName);

			// Generate schema name for banner comment
			const schemaName = schemaFile.filename
				.replace(".schema.json", "")
				.replace("-", " ")
				.split(" ")
				.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
				.join(" ");

			// Read and modify the schema to have a cleaner title
			const schemaContent = fs.readFileSync(schemaFile.path, "utf8");
			const schema = JSON.parse(schemaContent);

			// Override the title to get cleaner type names
			if (schemaFile.filename.includes("workflow")) {
				schema.title = "GitHubWorkflow";
			} else if (schemaFile.filename.includes("action")) {
				schema.title = "GitHubAction";
			}

			// Create a temporary schema file with the modified title
			const tempSchemaPath = path.join(schemaDir, `temp-${schemaFile.filename}`);
			fs.writeFileSync(tempSchemaPath, JSON.stringify(schema, null, 2));

			try {
				// Generate TypeScript types from the modified schema
				const ts = await compileFromFile(tempSchemaPath, {
					bannerComment: `/**
 * Generated TypeScript definitions for ${schemaName} Schema
 * 
 * This file is auto-generated from the ${schemaFile.filename} schema file.
 * Do not edit this file directly. Instead, modify the schema file
 * and regenerate the types using: npm run generate-types
 */`,
					style: {
						bracketSpacing: true,
						printWidth: 120,
						semi: true,
						singleQuote: true,
						tabWidth: 2,
						trailingComma: "es5",
						useTabs: false,
					},
					additionalProperties: false,
					enableConstEnums: true,
					format: true,
					ignoreMinAndMaxItems: false,
					maxItems: 20,
					strictIndexSignatures: false,
					unknownAny: true,
					unreachableDefinitions: false,
				});

				// Write the generated types to file
				fs.writeFileSync(outputPath, ts);
				console.log(`‚úÖ Types generated for ${schemaFile.filename} ‚Üí ${schemaFile.outputName}`);
				console.log(`üì¶ File size: ${(fs.statSync(outputPath).size / 1024).toFixed(2)} KB`);
			} finally {
				// Clean up the temporary schema file
				fs.unlinkSync(tempSchemaPath);
			}
		}

		console.log(`\nüéâ Successfully generated types for ${schemaFiles.length} schema file(s)!`);
		console.log(`üìÅ Output directory: ${outputDir}`);
	} catch (error) {
		console.error("‚ùå Error generating types:", error);
		process.exit(1);
	}
}

generateTypes();
