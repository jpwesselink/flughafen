import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { VulnerabilityValidator, clearAdvisoryCache } from "../VulnerabilityValidator";
import type { ValidationContext, WorkflowValidationResult } from "../../types";

describe("VulnerabilityValidator", () => {
	const createContext = (content: string, filePath: string, options = {}): ValidationContext => ({
		content,
		filePath,
		options: { verbose: false, silent: false, ...options },
	});

	const createResult = (): WorkflowValidationResult => ({
		file: "",
		valid: true,
		errors: [],
		warnings: [],
	});

	// Store original fetch
	let originalFetch: typeof global.fetch;

	beforeEach(() => {
		// Clear the advisory cache to ensure each test has a fresh state
		clearAdvisoryCache();
		originalFetch = global.fetch;
		// Default mock: return empty advisories (no vulnerabilities)
		global.fetch = vi.fn().mockResolvedValue({
			ok: true,
			json: () => Promise.resolve([]),
		});
	});

	afterEach(() => {
		global.fetch = originalFetch;
	});

	describe("Action extraction", () => {
		it("should extract actions from YAML workflow and check for vulnerabilities", async () => {
			const validator = new VulnerabilityValidator();
			const context = createContext(
				`name: Test
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4`,
				"test.yml"
			);
			const result = createResult();

			await validator.validate(context, result);

			// With no advisories returned, no errors should be added
			expect(result.errors).toHaveLength(0);
		});

		it("should extract actions from TypeScript workflow", async () => {
			const validator = new VulnerabilityValidator();
			const context = createContext(
				`import { createWorkflow } from '@flughafen/core';
export default createWorkflow()
  .name("Test")
  .on("push")
  .job("test", (job) => job
    .runsOn("ubuntu-latest")
    .step((step) => step.uses("actions/checkout@v4"))
    .step((step) => step.uses("actions/setup-node@v4"))
  );`,
				"test.ts"
			);
			const result = createResult();

			await validator.validate(context, result);

			expect(result.errors).toHaveLength(0);
		});

		it("should handle workflow with no actions", async () => {
			const validator = new VulnerabilityValidator();
			const context = createContext(
				`name: Test
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - run: echo hello`,
				"test.yml"
			);
			const result = createResult();

			await validator.validate(context, result);

			// No actions to check, should pass
			expect(result.errors).toHaveLength(0);
			// Fetch should not be called when there are no actions
			expect(global.fetch).not.toHaveBeenCalled();
		});

		it("should handle quoted action references in YAML", async () => {
			const validator = new VulnerabilityValidator();
			const context = createContext(
				`name: Test
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: "actions/checkout@v4"
      - uses: 'actions/setup-node@v4'`,
				"test.yml"
			);
			const result = createResult();

			await validator.validate(context, result);

			expect(result.errors).toHaveLength(0);
		});

		it("should handle actions with SHA references", async () => {
			const validator = new VulnerabilityValidator();
			const context = createContext(
				`name: Test
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608`,
				"test.yml"
			);
			const result = createResult();

			await validator.validate(context, result);

			expect(result.errors).toHaveLength(0);
		});

		it("should report vulnerability when action is in advisory database", async () => {
			global.fetch = vi.fn().mockResolvedValue({
				ok: true,
				json: () =>
					Promise.resolve([
						{
							ghsa_id: "GHSA-1234-5678-9abc",
							cve_id: "CVE-2024-1234",
							summary: "Critical vulnerability in test action",
							severity: "high",
							vulnerabilities: [
								{
									package: { ecosystem: "actions", name: "test-org/vulnerable-action" },
									vulnerable_version_range: "<= 1.0.0",
									first_patched_version: "1.0.1",
								},
							],
						},
					]),
			});

			const validator = new VulnerabilityValidator();
			const context = createContext(
				`name: Test
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: test-org/vulnerable-action@v1`,
				"test.yml"
			);
			const result = createResult();

			await validator.validate(context, result);

			expect(result.errors).toHaveLength(1);
			expect(result.errors[0].rule).toBe("security");
			expect(result.errors[0].message).toContain("GHSA-1234-5678-9abc");
		});
	});

	describe("API error handling", () => {
		it("should add warning when API fails", async () => {
			global.fetch = vi.fn().mockRejectedValue(new Error("Network error"));

			const validator = new VulnerabilityValidator();
			const context = createContext(
				`name: Test
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4`,
				"test.yml"
			);
			const result = createResult();

			await validator.validate(context, result);

			// Should add warning about failed check
			expect(result.warnings).toHaveLength(1);
			expect(result.warnings[0].rule).toBe("security");
		});

		it("should add warning about rate limiting when unauthenticated", async () => {
			const originalEnv = process.env.GITHUB_TOKEN;
			delete process.env.GITHUB_TOKEN;

			global.fetch = vi.fn().mockResolvedValue({
				ok: false,
				status: 403,
			});

			const validator = new VulnerabilityValidator();
			const context = createContext(
				`name: Test
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4`,
				"test.yml"
			);
			const result = createResult();

			await validator.validate(context, result);

			expect(result.warnings).toHaveLength(1);
			expect(result.warnings[0].message).toContain("GITHUB_TOKEN");

			if (originalEnv) process.env.GITHUB_TOKEN = originalEnv;
		});
	});
});
