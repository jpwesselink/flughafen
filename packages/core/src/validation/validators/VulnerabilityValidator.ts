import type { ValidationContext, ValidatorFunction, WorkflowValidationResult } from "../types";

interface Advisory {
	ghsa_id: string;
	cve_id: string | null;
	summary: string;
	severity: string;
	vulnerabilities: Array<{
		package: { ecosystem: string; name: string };
		vulnerable_version_range: string;
		first_patched_version: string | null;
	}>;
}

// Cache advisories for 1 hour
let advisoryCache: { data: Advisory[]; timestamp: number } | null = null;
const CACHE_TTL = 60 * 60 * 1000;

/**
 * Fetches GitHub Security Advisories for actions ecosystem
 */
async function fetchAdvisories(): Promise<Advisory[]> {
	if (advisoryCache && Date.now() - advisoryCache.timestamp < CACHE_TTL) {
		return advisoryCache.data;
	}

	const response = await fetch("https://api.github.com/advisories?ecosystem=actions&per_page=100", {
		headers: {
			Accept: "application/vnd.github+json",
			"X-GitHub-Api-Version": "2022-11-28",
		},
	});

	if (!response.ok) {
		throw new Error(`GitHub API error: ${response.status}`);
	}

	const data = (await response.json()) as Advisory[];
	advisoryCache = { data, timestamp: Date.now() };
	return data;
}

/**
 * Extracts action references from workflow content
 * Matches both YAML (uses: action@version) and TS (.uses("action@version"))
 */
function extractActions(content: string): Array<{ name: string; version: string }> {
	const actions: Array<{ name: string; version: string }> = [];

	// YAML: uses: owner/action@version
	const yamlPattern = /uses:\s*['"]?([^@\s'"]+)@([^\s'"]+)['"]?/g;
	// TS: .uses("owner/action@version") or .uses('owner/action@version')
	const tsPattern = /\.uses\(\s*['"]([^@'"]+)@([^'"]+)['"]/g;

	for (const pattern of [yamlPattern, tsPattern]) {
		let match: RegExpExecArray | null;
		while ((match = pattern.exec(content)) !== null) {
			actions.push({ name: match[1], version: match[2] });
		}
	}

	return actions;
}

/**
 * Checks if a version matches a vulnerability range
 * Simplified: flags all matches for review (conservative approach)
 * TODO: Add proper semver matching for precise version range checking
 */
function isVulnerable(_version: string, _range: string): boolean {
	// For now, flag any action that appears in the advisory
	// Proper semver range matching would require additional dependencies
	return true;
}

/**
 * Vulnerability validator
 * Checks actions against GitHub Security Advisory Database
 */
export class VulnerabilityValidator {
	async validate(context: ValidationContext, result: WorkflowValidationResult): Promise<void> {
		// Skip if disabled via options
		if (context.options.skipVulnerabilityCheck) return;

		try {
			const actions = extractActions(context.content);
			if (actions.length === 0) return;

			const advisories = await fetchAdvisories();

			for (const action of actions) {
				for (const advisory of advisories) {
					for (const vuln of advisory.vulnerabilities) {
						if (vuln.package.name === action.name && isVulnerable(action.version, vuln.vulnerable_version_range)) {
							const patched = vuln.first_patched_version ? ` (patched in ${vuln.first_patched_version})` : "";

							result.errors.push({
								path: context.filePath,
								message: `${action.name}@${action.version}: ${advisory.summary}${patched} [${advisory.ghsa_id}]`,
								severity: "error",
								rule: "vulnerable-action",
							});
						}
					}
				}
			}
		} catch (error) {
			result.warnings.push({
				path: context.filePath,
				message: `Vulnerability check skipped: ${error instanceof Error ? error.message : error}`,
				severity: "warning",
				rule: "vulnerability-check-error",
			});
		}
	}
}

/**
 * Validator function for use with WorkflowValidator
 */
export const validateVulnerabilities: ValidatorFunction = async (context, result) => {
	const validator = new VulnerabilityValidator();
	await validator.validate(context, result);
};
